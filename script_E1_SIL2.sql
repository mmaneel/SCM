DROP TABLE ligne_commande;
DROP TABLE commande;
DROP TABLE Carte;
DROP TABLE client;
DROP TABLE Address;
DROP TABLE Produit;
DROP TABLE typeCarte;

CREATE TABLE typeCarte (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nom VARCHAR2(255) NOT NULL
);

CREATE TABLE Produit (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    code_produit NUMBER NOT NULL,
    nom_produit VARCHAR2(255) NOT NULL,
    Quantite_enStock NUMBER NOT NULL,
    prix_unitaire FLOAT NOT NULL,
    description VARCHAR2(255) NOT NULL
);

CREATE TABLE Address (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    distinaire VARCHAR2(255) NOT NULL,
    code_postal NUMBER NOT NULL
);

CREATE TABLE client (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nom_client VARCHAR2(255) NOT NULL,
    prenom_client VARCHAR2(255) NOT NULL,
    num_tel NUMBER NOT NULL
);

CREATE TABLE Carte (
    numero VARCHAR2(16) PRIMARY KEY,
    cvv NUMBER(3) NOT NULL,
    date_exp NUMBER(4) NOT NULL,
    balance NUMBER(10) NOT NULL,
    type_id NUMBER(3) NOT NULL,
    client_id NUMBER NOT NULL,
    CONSTRAINT Carte_fk4 FOREIGN KEY (type_id) REFERENCES typeCarte(id),
    CONSTRAINT Carte_fk5 FOREIGN KEY (client_id) REFERENCES client(id)
);

CREATE TABLE commande (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    commande_date DATE NOT NULL,
    status NUMBER NOT NULL,
    prix_total NUMBER NOT NULL,
    id_client NUMBER NOT NULL,
    adresse_id NUMBER NOT NULL,
    CONSTRAINT commande_fk4 FOREIGN KEY (id_client) REFERENCES client(id),
    CONSTRAINT commande_fk5 FOREIGN KEY (adresse_id) REFERENCES Address(id)
);

CREATE TABLE ligne_commande (
    id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_produit NUMBER NOT NULL,
    id_commande NUMBER NOT NULL,
    Qte NUMBER NOT NULL,
    CONSTRAINT ligne_commande_fk1 FOREIGN KEY (id_produit) REFERENCES Produit(id),
    CONSTRAINT ligne_commande_fk2 FOREIGN KEY (id_commande) REFERENCES commande(id)
);

-- Insertion des types de carte
INSERT INTO typeCarte (nom) VALUES ('Visa');
INSERT INTO typeCarte (nom) VALUES ('PayPal');
INSERT INTO typeCarte (nom) VALUES ('Mastercard');

-- Insertion des adresses
INSERT INTO Address (distinaire, code_postal) VALUES ('123 Rue de la Liberté, VilleA', 12345);
INSERT INTO Address (distinaire, code_postal) VALUES ('456 Avenue des Fleurs, VilleB', 54321);
INSERT INTO Address (distinaire, code_postal) VALUES ('789 Boulevard Principal, VilleC', 67890);

-- Insertion des clients
INSERT INTO client (nom_client, prenom_client, num_tel) VALUES ('Smith', 'John', 123456789);
INSERT INTO client (nom_client, prenom_client, num_tel) VALUES ('Doe', 'Jane', 987654321);
INSERT INTO client (nom_client, prenom_client, num_tel) VALUES ('Johnson', 'Michael', 654321987);

-- Insertion des cartes associées aux clients
INSERT INTO Carte (numero, cvv, date_exp, balance, type_id, client_id) VALUES ('1111222233334444', 123, 1225, 500, 1, 1); -- Visa pour John Smith
INSERT INTO Carte (numero, cvv, date_exp, balance, type_id, client_id) VALUES ('5555666677778888', 456, 0623, 1000, 2, 2); -- PayPal pour Jane Doe
INSERT INTO Carte (numero, cvv, date_exp, balance, type_id, client_id) VALUES ('9999888877776666', 789, 0324, 1500, 3, 3); -- Mastercard pour Michael Johnson
INSERT INTO Carte (numero, cvv, date_exp, balance, type_id, client_id) VALUES ('1234123412341234', 101, 1226, 200, 1, 1); -- Deuxième carte Visa pour John Smith

-- Insertion des produits
INSERT INTO Produit (code_produit, nom_produit, Quantite_enStock, prix_unitaire, description) 
VALUES (1, 'IPHONE', 10, 500.00, 'Smartphone dernier cri avec des fonctionnalités avancées');

INSERT INTO Produit (code_produit, nom_produit, Quantite_enStock, prix_unitaire, description) 
VALUES (2, 'OPPO', 15, 400.00, 'Téléphone Android abordable avec un bon rapport qualité-prix');

INSERT INTO Produit (code_produit, nom_produit, Quantite_enStock, prix_unitaire, description) 
VALUES (3, 'REDMI', 20, 600.00, 'iPhone haut de gamme avec un design élégant et des performances exceptionnelles');

-- Insertion des commandes
INSERT INTO commande (commande_date, status, prix_total, id_client, adresse_id) VALUES (CURRENT_DATE, 1, 200, 1, 1); -- Commande du client 1 à l'adresse 1
INSERT INTO commande (commande_date, status, prix_total, id_client, adresse_id) VALUES (CURRENT_DATE, 1, 300, 2, 2); -- Commande du client 2 à l'adresse 2
INSERT INTO commande (commande_date, status, prix_total, id_client, adresse_id) VALUES (CURRENT_DATE, 1, 400, 3, 3); -- Commande du client 3 à l'adresse 3

-- Insertion des lignes de commande
INSERT INTO ligne_commande (id_produit, id_commande, Qte) VALUES (1, 1, 1);
INSERT INTO ligne_commande (id_produit, id_commande, Qte) VALUES (2, 2, 2);
INSERT INTO ligne_commande (id_produit, id_commande, Qte) VALUES (3, 3, 3);


-- ---------------------------------------------------------------- CODE -------------------------------------------------------------------

-- Créer le type pour les produits et quantités
CREATE OR REPLACE TYPE product_quantity_type AS OBJECT (
    product_id NUMBER,
    quantity NUMBER
);

COMMIT;



SET SERVEROUTPUT ON


CREATE OR REPLACE TYPE product_quantity_type AS OBJECT (
    product_id NUMBER,
    quantity NUMBER
);


CREATE OR REPLACE TYPE product_quantity_table AS TABLE OF product_quantity_type;


CREATE OR REPLACE FUNCTION calculate_order_total (
    p_product_quantity IN product_quantity_table
)
RETURN NUMBER
IS
    v_total_amount NUMBER := 0;
    v_amount NUMBER := 0;
BEGIN
    FOR i IN 1..p_product_quantity.COUNT LOOP
        SELECT prix_unitaire * p_product_quantity(i).quantity
        INTO v_amount
        FROM Produit
        WHERE id = p_product_quantity(i).product_id;
        v_total_amount := v_amount + v_total_amount;
    END LOOP;
     DBMS_OUTPUT.PUT_LINE('Montant total de la commande : ' || v_total_amount);
    RETURN v_total_amount;
END;
/


CREATE OR REPLACE PROCEDURE remettre_produits_en_stock (
    p_commande_id IN NUMBER
)
IS
BEGIN
    -- Remettre les produits en stock
    FOR ligne IN (
        SELECT id_produit, Qte
        FROM ligne_commande
        WHERE id_commande = p_commande_id
    )
    LOOP
        UPDATE Produit
        SET Quantite_enStock = Quantite_enStock + ligne.Qte
        WHERE id = ligne.id_produit;
    END LOOP;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

CREATE OR REPLACE PROCEDURE mettre_a_jour_solde_carte (
    p_numero_carte IN VARCHAR2,
    p_montant_total IN NUMBER
)
IS
BEGIN
    -- Mettre à jour le solde de la carte
    UPDATE Carte
    SET balance = balance - p_montant_total
    WHERE numero = p_numero_carte;

    COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END;
/

CREATE OR REPLACE FUNCTION check_stock_availability(
    p_product_id IN NUMBER,
    p_quantity IN NUMBER
)
RETURN BOOLEAN
IS
    v_quantite_en_stock NUMBER;
BEGIN
    SELECT Quantite_enStock INTO v_quantite_en_stock
    FROM Produit
    WHERE id = p_product_id;

    RETURN v_quantite_en_stock >= p_quantity;
END;
/


CREATE OR REPLACE PROCEDURE create_commande(
    p_nom_client IN VARCHAR2,
    p_prenom_client IN VARCHAR2,
    p_num_tel IN NUMBER,
    p_numero_carte IN VARCHAR2,
    p_cvv IN NUMBER,
    p_date_exp IN NUMBER,
    p_balance IN NUMBER,
    p_type_id IN NUMBER,
    p_adresse IN VARCHAR2,
    p_code_postal IN NUMBER,
    p_product_quantity IN product_quantity_table
)
IS
    v_client_id NUMBER;
    v_adresse_id NUMBER;
    v_commande_id NUMBER;
    v_prix_unitaire NUMBER;
    v_carte_id VARCHAR2(16);
    v_montant_total NUMBER := 0; -- Total amount for all products
BEGIN
BEGIN
    -- Vérifier si le client existe déjà
    SELECT id INTO v_client_id
    FROM client
    WHERE nom_client = p_nom_client
        AND prenom_client = p_prenom_client
        AND num_tel = p_num_tel;
EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Si le client  n'existe pas, alors l'insérer
           INSERT INTO client (nom_client, prenom_client, num_tel)
 VALUES (p_nom_client, p_prenom_client, p_num_tel)
            RETURNING id INTO v_client_id;
    END;


      -- Vérifier si la carte existe déjà
    DECLARE
        v_carte_id VARCHAR2(16);
    BEGIN
        SELECT numero INTO v_carte_id
        FROM Carte
        WHERE numero = p_numero_carte;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Si la carte n'existe pas, alors l'insérer
            INSERT INTO Carte (numero, cvv, date_exp, balance, type_id, client_id)
            VALUES (p_numero_carte, p_cvv, p_date_exp, p_balance, p_type_id, v_client_id)
            RETURNING numero INTO v_carte_id;
    END;
  BEGIN
    -- Vérifier si l'adresse existe déjà
    SELECT id INTO v_adresse_id
    FROM Address
    WHERE distinaire = p_adresse AND code_postal = p_code_postal;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            -- Si l'adress n'existe pas, alors l'insérer
           INSERT INTO Address (distinaire, code_postal)
            VALUES (p_adresse, p_code_postal)
            RETURNING id INTO v_adresse_id;
    END;
    
     -- Calculate the total order amount using the function
    v_montant_total := calculate_order_total(p_product_quantity);

    -- Insérer la commande
    INSERT INTO commande (commande_date, status, prix_total, id_client, adresse_id)
    VALUES (CURRENT_DATE, 1, v_montant_total, v_client_id, v_adresse_id)
    RETURNING id INTO v_commande_id;

-- Loop through the product_quantity collection
    FOR i IN 1..p_product_quantity.COUNT LOOP
        -- Retrieve product_id and quantity
        DECLARE
            v_product_id NUMBER := p_product_quantity(i).product_id;
            v_quantity NUMBER := p_product_quantity(i).quantity;
            v_prix_unitaire NUMBER;
            v_montant_commande NUMBER;
        BEGIN
            -- Récupérer le prix unitaire du produit
            SELECT prix_unitaire INTO v_prix_unitaire
            FROM Produit
            WHERE id = v_product_id;
            
            -- Vérifier si le stock est suffisant pour la quantité commandée
            IF NOT check_stock_availability(v_product_id, v_quantity) THEN
                RAISE_APPLICATION_ERROR(-20003, 'La quantité commandée pour le produit ' || v_product_id || ' est supérieure au stock disponible.');
            END IF;

            -- Insérer la ligne de commande
            INSERT INTO ligne_commande (id_produit, id_commande, Qte)
            VALUES (v_product_id, v_commande_id, v_quantity);

            -- Mettre à jour les niveaux de stock des produits commandés
            UPDATE Produit
            SET Quantite_enStock = Quantite_enStock - v_quantity
            WHERE id = v_product_id;

        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE_APPLICATION_ERROR(-20002, 'Le produit avec l''ID ' || v_product_id || ' est introuvable.'); 
        END;
    END LOOP;

    -- Vérifier si le solde de la carte est suffisant
    IF p_balance < v_montant_total THEN
        RAISE_APPLICATION_ERROR(-20001, 'Solde de la carte insuffisant pour passer la commande.');
    END IF;
 

    -- Mettre à jour le solde de la carte
       mettre_a_jour_solde_carte(p_numero_carte,v_montant_total);
   

      COMMIT;
EXCEPTION
    WHEN OTHERS THEN
        -- Rollback the transaction and delete the command if an error occurs
        ROLLBACK;
        RAISE;
END;
/

DECLARE
    l_product_quantity product_quantity_table;

BEGIN
    l_product_quantity := product_quantity_table(
        product_quantity_type(1, 1), -- product_id, quantity
        product_quantity_type(2, 1)
    );

    create_commande(
        'Doe', -- p_nom_client
        'Jane', -- p_prenom_client
        987654321, -- p_num_tel
        '5555666677778888', -- p_numero_carte (nouvelle)
        456, -- p_cvv
        623, -- p_date_exp (format MMYY)
        1000000, -- p_balance
        2, -- p_type_id (PayPal)
        '456 Avenue des Fleurs, VilleB', -- p_adresse (existante)
        54321, -- p_code_postal (existant)
        l_product_quantity -- Pass the collection
    );

    -- Output success message
    DBMS_OUTPUT.PUT_LINE('Commande créée avec succès !');
EXCEPTION
    WHEN OTHERS THEN
        -- Output error message
        DBMS_OUTPUT.PUT_LINE('Une erreur s''est produite: ' || SQLERRM);
END;
/


CREATE OR REPLACE TRIGGER suivre_commande_trigger
AFTER INSERT OR UPDATE ON commande
FOR EACH ROW
DECLARE
    v_statut VARCHAR2(100);
BEGIN
    -- Récupérer le statut de la commande mise à jour
    SELECT 
        CASE :NEW.status
            WHEN 1 THEN 'Créer'
            WHEN 2 THEN 'Validée'
            WHEN 3 THEN 'En transit'
            WHEN 4 THEN 'Livraison réussie'
            WHEN 5 THEN 'Annulée'
            WHEN 6 THEN 'En attente de stock'
            WHEN 7 THEN 'Retardée'
            WHEN 8 THEN 'Remboursée'
            ELSE 'Statut inconnu'
        END
    INTO v_statut
    FROM dual;

    -- Afficher le suivi en temps réel de la commande
    DBMS_OUTPUT.PUT_LINE('Suivi en temps réel de la commande ' || :NEW.id || ' : ' || v_statut);
END;
/

CREATE OR REPLACE PROCEDURE afficher_message(
    p_sujet IN VARCHAR2,
    p_corps IN VARCHAR2
)
IS
   
BEGIN

    DBMS_OUTPUT.PUT_LINE('Subject: ' || p_sujet);
    DBMS_OUTPUT.PUT_LINE('Body: ' || p_corps);
END afficher_message;
/

CREATE OR REPLACE PROCEDURE maj_statut_commande(
    p_commande_id IN commande.id%TYPE,
    p_nouveau_statut IN commande.status%TYPE
) AS
BEGIN
     
    CASE p_nouveau_statut
    
    WHEN 1 THEN -- Créée
        NULL; 
    WHEN 2 THEN -- Valider 
        NULL; 
    WHEN 3 THEN -- En transit
                   
        afficher_message('Commande en transit', 'Votre commande est en cours de livraison.');


    WHEN 4 THEN -- Livraison réussie

        NULL; -- Aucun traitement supplémentaire nécessaire

    WHEN 5 THEN -- Annulée
        -- Remettre les produits en stock
       remettre_produits_en_stock(p_commande_id);
       
    WHEN 6 THEN -- En attente de stock

            -- Envoyer un e-mail de notification au client
            afficher_message('Commande en attente de stock', 'Votre commande est en attente de disponibilité des produits en stock.');

   
   WHEN 7 THEN -- Retardée
  
            -- Envoyer un e-mail de notification au client
            afficher_message('Commande retardée', 'Votre commande a été retardée pour des raisons logistiques.');


    WHEN 8 THEN -- Remboursée
        -- créditer le compte du client
        DECLARE
            v_numero_carte Carte.numero%TYPE;
            v_montant_rembourse commande.prix_total%TYPE;
        BEGIN
            SELECT c.numero, co.prix_total
            INTO v_numero_carte, v_montant_rembourse
            FROM commande co
            JOIN client cl ON co.id_client = cl.id
            JOIN Carte c ON cl.id = c.client_id
            WHERE co.id = p_commande_id;
            
            mettre_a_jour_solde_carte(v_numero_carte, -v_montant_rembourse);
        END;
END CASE;

    UPDATE commande
    SET status = p_nouveau_statut
    WHERE id = p_commande_id;


EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20002, 'Une erreur est survenue lors de la mise à jour du statut de la commande : ' || SQLERRM);
END;
/

BEGIN
    maj_statut_commande(1, 3); 
    maj_statut_commande(2, 8);
END;
/


DECLARE
    -- Define cursor for fetching orders
    CURSOR orders_cursor IS
        SELECT c.nom_client, c.prenom_client, c.num_tel, cmd.id, cmd.commande_date, cmd.prix_total, cmd.status 
        FROM client c
        JOIN commande cmd ON c.id = cmd.id_client;
BEGIN
    -- Iterate through each row fetched by the cursor
    FOR order_row IN orders_cursor LOOP
        -- Access individual column values using cursor record
        DBMS_OUTPUT.PUT_LINE('Client: ' || order_row.nom_client || ' ' || order_row.prenom_client || ', Numéro de téléphone: ' || order_row.num_tel || ', Commande ID: ' || order_row.id || ', Date: ' || order_row.commande_date || ', Total: ' || order_row.prix_total||', Statut: ' || order_row.status);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
/

DECLARE
    -- Define cursor for fetching products
    CURSOR products_cursor IS
        SELECT id, nom_produit, Quantite_enStock
        FROM Produit;
BEGIN
    -- Iterate through each row fetched by the cursor
    FOR product_row IN products_cursor LOOP
        -- Access individual column values using cursor record
        DBMS_OUTPUT.PUT_LINE('Produit ID: ' || product_row.id || ', Nom: ' || product_row.nom_produit || ', Quantité en stock: ' || product_row.Quantite_enStock);
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        -- Handle exceptions
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
/

CREATE OR REPLACE PROCEDURE alert_quantite AS 
   quantite_en_stock NUMBER;
BEGIN 
   FOR produit_row IN (SELECT * FROM Produit) LOOP
      quantite_en_stock := produit_row.Quantite_enStock;

      IF quantite_en_stock < 25 THEN       
         RAISE_APPLICATION_ERROR(-20001, 'Quantité en stock du produit ' || produit_row.nom_produit || ' est très basse');
      END IF;
   END LOOP;
END;
/

CREATE OR REPLACE PROCEDURE alert_quantite AS 
   quantite_en_stock NUMBER;
BEGIN 
   FOR produit_row IN (SELECT * FROM Produit) LOOP
      quantite_en_stock := produit_row.Quantite_enStock;

      IF quantite_en_stock < 25 THEN       
         RAISE_APPLICATION_ERROR(-20001, 'Quantité en stock du produit ' || produit_row.nom_produit || ' est très basse');
      END IF;
   END LOOP;
END;
/









BEGIN
   DBMS_SCHEDULER.create_job (
      job_name        => 'alert_quantite_job',
      job_type        => 'PLSQL_BLOCK',
      job_action      => 'BEGIN alert_quantite; END;',
      start_date      => SYSTIMESTAMP,
      repeat_interval => 'freq=daily; byhour=9; byminute=0; bysecond=0;',
      end_date        => NULL,
      enabled         => TRUE,
      comments        => 'Job pour vérifier la quantité en stock tous les jours à 9h00.'
   );
END;
/


select * from  carte;
select * from client;
select * from Address;
select * from Commande;
select * from ligne_commande;
select * from produit;
select * from Typecarte;


